# 静态点分治

## 树的重心

1. 假设树的节点数为 `n` ，如果选择点 `x` 作为树头时， `x` 的每棵子树大小 `<= n/2` ，那么 `x` 就是树的重心。
2. 树的重心可能有 `1` 个或 `2` 个。

## 寻找重心的过程

1. 遍历以 `u` 为头的子树，建立每个节点的子树大小信息，并且得到整棵子树的节点数量 `n` 。
2. 从 `u` 开始往下方寻找重心，依次考察 `u` 的每个儿子 `v` 。
3. 如果发现 `v` 的子树大小 `> n/2` ，那么令 `u = v` ，重复步骤 `2` 。
4. 如果发现 `u` 的每个儿子的子树大小 `<= n/2` ，那么当前节点 `u` 就是重心。

## 静态点分治（重心分解）

1. 来到当前的树，遍历并找到树的重心 `x` 。
2. 可以再次遍历树，去收集必要信息，然后求解和重心x有关的答案。
3. 重心 `x` 的每棵子树，继续重复步骤 `1` ，直到把答案都求解出来。

## 静态点分治的理解核心

1. 树上选择不同的点作为头，都不会影响答案的求解。
2. 答案来源有两种，跨过头产生的答案、头的每棵子树内的答案。
3. 每次来到一棵子树，为了找重心或者收集信息，允许遍历当前的子树有限次，这提供了极大的便利性。
4. 每次都把当前子树的重心选为树头，然后分治下去，整个过程的时间复杂度 `O(n * log n)` 。

## 静态点分治的经典方法

1. `getCentroid(int u, int fa)` ：找到子树 `u` 的重心。
2. `dfs(int u, int fa)` ：在子树u上收集信息。
3. `calc(int u)` ：求解和重心 `u` 有关的答案。
4. `solve(int u)` ：对子树 `u` 进行静态点分治。

## 注意

- 每来到一棵子树，节点数量的信息需要重新计算，网上大部分写法是有问题的
