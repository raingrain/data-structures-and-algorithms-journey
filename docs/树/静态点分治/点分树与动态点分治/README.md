# 点分树和动态点分治

动态点分治，就是在查询的基础上，又有修改操作，点分树是保证修改/查询都能快速完成的关键。

## 点分树

1. 点分治的过程中，每次求出一棵子树的重心。
2. 记录每个重心的上级重心，等同于记录了一棵重构的树。
3. 这棵重构的树叫点分树，高度为 `O(log n)` 。
4. 当然可以完整记录点分树，不过一般情况下，只记录上级重心就够了。

## 点分树的性质

1. 点分树上的一个子树，一定是原树的一个联通块。
2. 点分树上两点的 `LCA` ，一定在原树两点的简单路径上。
3. 除此之外，点分树和原树的联系很少。

## 点分树的作用

1. 原树的点对 `(x, y)` ，在点分树上的最低公共祖先记为 `c` ， `c` 在两点的简单路径上。
2. 所以 `dist(x, y) = dist(x, c) + dist(y, c)` ， `dist` 指原树距离。
3. 讨论点 `x` 与其他点的某些答案时，尤其是 和距离有关的 某些答案时，可以对其他点进行分类。
4. 根据来自 `x` 点的哪个祖先重心，其他点最多被分成 `O(log n)` 类，可能性的数量很少。

## 核心是修改与查询到底怎么维护信息？

1. 点分树上，点 `x` 的信息，会被上方多个祖先重心统计，作为每个祖先重心的子树信息。
2. 一个节点的信息，会被多次统计，所以需要容斥逻辑。
3. 修改时，从 `x` 往上的链中，每个上级重心加入了统计，每个下级重心就减少统计。
4. 查询时，从 `x` 往上的链中，每获得上级重心的统计，就减少下级重心的统计，防止重复计算。
