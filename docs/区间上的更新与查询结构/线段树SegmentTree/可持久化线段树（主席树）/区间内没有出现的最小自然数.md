# 区间内没有出现的最小自然数

## [P4137 Rmq Problem / mex](https://www.luogu.com.cn/problem/P4137)

> - **Question**
>   - 给定一个长度为 `n` 的数组 `arr` ，下标 `1 ~ n` ，一共有 `m` 条查询，每条查询 `l r` ：打印 `arr[l ~ r]` 内没有出现过的最小自然数，注意 `0` 是自然数，请用在线算法解决该问题，因为可以设计强制在线的要求，让离线算法失效。
>   - **Tips**
>     - `1 <= n、m <= 2 *10^5`
>     - `0 <= arr[i] <= 2* 10^5`

## Java

> - **值域范围分析 + 值域线段树维护特别信息**

```java
// 数字范围内，每个数最后出现的位置中，最左在什么位置

// For Most Online Judge systems

import java.io.*;
import java.util.*;

public class Main {

    public static int MAXN = 200001;

    public static int MAXT = MAXN * 22;

    public static int n, m;

    public static int[] arr = new int[MAXN];

    public static int[] root = new int[MAXN];

    public static int[] left = new int[MAXT];

    public static int[] right = new int[MAXT];

    // 数字范围中，每个数字出现的最晚位置中，最左的位置在哪
    public static int[] lateLeft = new int[MAXT];

    public static int cnt;

    public static int build(int l, int r) {
        int rt = ++cnt;
        lateLeft[rt] = 0;
        if (l < r) {
            int mid = (l + r) / 2;
            left[rt] = build(l, mid);
            right[rt] = build(mid + 1, r);
        }
        return rt;
    }

    // 数字范围l~r，信息在i号节点
    // 数字范围上，jobi这个数字，最晚出现的位置更新为jobv
    // 返回新的头节点编号
    public static int update(int jobi, int jobv, int l, int r, int i) {
        int rt = ++cnt;
        left[rt] = left[i];
        right[rt] = right[i];
        lateLeft[rt] = lateLeft[i];
        if (l == r) {
            lateLeft[rt] = jobv;
        } else {
            int mid = (l + r) / 2;
            if (jobi <= mid) {
                left[rt] = update(jobi, jobv, l, mid, left[rt]);
            } else {
                right[rt] = update(jobi, jobv, mid + 1, r, right[rt]);
            }
            lateLeft[rt] = Math.min(lateLeft[left[rt]], lateLeft[right[rt]]);
        }
        return rt;
    }

    // 数字在l~r范围上，没有出现的最小自然数
    public static int query(int pos, int l, int r, int i) {
        if (l == r) {
            return l;
        }
        int mid = (l + r) / 2;
        if (lateLeft[left[i]] < pos) {
            // l...mid范围上，每个数字最晚出现的位置中
            // 最左的位置如果在pos以左，说明l...mid范围上，一定有缺失的数字
            return query(pos, l, mid, left[i]);
        } else {
            // 缺失的数字一定在mid+1....r范围
            // 因为l...r一定有缺失的数字才会来到这个范围的
            // 如果左侧不缺失，那缺失的数字一定在右侧范围上
            return query(pos, mid + 1, r, right[i]);
        }
    }

    public static void prepare() {
        cnt = 0;
        root[0] = build(0, n);
        for (int i = 1; i <= n; i++) {
            if (arr[i] > n || arr[i] < 0) {
                root[i] = root[i - 1];
            } else {
                root[i] = update(arr[i], i, 0, n, root[i - 1]);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        in.nextToken();
        n = (int) in.nval;
        in.nextToken();
        m = (int) in.nval;
        for (int i = 1; i <= n; i++) {
            in.nextToken();
            arr[i] = (int) in.nval;
        }
        prepare();
        for (int i = 1, l, r; i <= m; i++) {
            in.nextToken();
            l = (int) in.nval;
            in.nextToken();
            r = (int) in.nval;
            out.println(query(l, 0, n, root[r]));
        }
        out.flush();
        out.close();
        br.close();
    }

}
```

> - **只删回滚莫队**

```java
// For Most Online Judge systems

import java.io.*;
import java.util.*;

public class Main {

    public static int MAXN = 200001;
    public static int MAXB = 501;
    public static int n, m;
    public static int[] arr = new int[MAXN];
    public static int[][] query = new int[MAXN][3];

    public static int blen, bnum;
    public static int[] bi = new int[MAXN];
    public static int[] bl = new int[MAXB];

    public static int[] cnt = new int[MAXN];
    public static int mex;
    public static int[] ans = new int[MAXN];

    // 只删回滚莫队经典排序
    public static class QueryCmp implements Comparator<int[]> {

        @Override
        public int compare(int[] a, int[] b) {
            if (bi[a[0]] != bi[b[0]]) {
                return bi[a[0]] - bi[b[0]];
            }
            return b[1] - a[1];
        }

    }

    public static void del(int num) {
        if (--cnt[num] == 0) {
            mex = Math.min(mex, num);
        }
    }

    public static void add(int num) {
        cnt[num]++;
    }

    public static void compute() {
        for (int i = 1; i <= n; i++) {
            cnt[arr[i]]++;
        }
        mex = 0;
        while (cnt[mex] != 0) {
            mex++;
        }
        int winl = 1, winr = n;
        for (int block = 1, qi = 1; block <= bnum && qi <= m; block++) {
            while (winl < bl[block]) {
                del(arr[winl++]);
            }
            int beforeJob = mex;
            for (; qi <= m && bi[query[qi][0]] == block; qi++) {
                int jobl = query[qi][0];
                int jobr = query[qi][1];
                int id = query[qi][2];
                while (winr > jobr) {
                    del(arr[winr--]);
                }
                int backup = mex;
                while (winl < jobl) {
                    del(arr[winl++]);
                }
                ans[id] = mex;
                mex = backup;
                while (winl > bl[block]) {
                    add(arr[--winl]);
                }
            }
            while (winr < n) {
                add(arr[++winr]);
            }
            mex = beforeJob;
        }
    }

    public static void prepare() {
        blen = (int) Math.sqrt(n);
        bnum = (n + blen - 1) / blen;
        for (int i = 1; i <= n; i++) {
            bi[i] = (i - 1) / blen + 1;
        }
        for (int i = 1; i <= bnum; i++) {
            bl[i] = (i - 1) * blen + 1;
        }
        Arrays.sort(query, 1, m + 1, new QueryCmp());
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        n = in.nextInt();
        m = in.nextInt();
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }
        for (int i = 1; i <= m; i++) {
            query[i][0] = in.nextInt();
            query[i][1] = in.nextInt();
            query[i][2] = i;
        }
        prepare();
        compute();
        for (int i = 1; i <= m; i++) {
            out.println(ans[i]);
        }
        out.flush();
        out.close();
    }

    // 读写工具类
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}
```
