# 受欢迎的牛

## [[USACO03FALL / HAOI2006] 受欢迎的牛 G](<https://www.luogu.com.cn/problem/P2341>)

> - **Question**
>   - 每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的：如果 `A` 喜欢 `B` ， `B` 喜欢 `C` ，那么 `A` 也喜欢 `C` 。牛栏里共有 `N` 头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。
>   - **输入描述**
>     - 第一行：两个用空格分开的整数 `N` 和 `M` 。
>     - 接下来 `M` 行：每行两个用空格分开的整数： `A` 和 `B` ，表示 `A` 喜欢 `B` 。
>   - **输出描述**
>     - 一行单独一个整数，表示明星奶牛的数量。
>   - **Tips**
>     - 对于 `10%` 的数据， `N <= 20, M <= 50`
>     - 对于 `30%` 的数据， `N <= 10^3, M <= 2 * 10^4`
>     - 对于 `70%` 的数据， `N <= 5 * 10^3, M <= 5 * 10^4`
>     - 对于 `100%` 的数据， `1 <= N <= 10^4, 1 <= M <= 5 * 10^4`

## Java

> - **tarjan**
>   - 缩点图中如果有多个出度为 `0` 的超级节点（强连通分量），没有明星，如果只有一个，那么这个超级节点代表的强连通分量中的节点个数就是答案。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.ArrayList;
import java.util.HashSet;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while (in.nextToken() != StreamTokenizer.TT_EOF) {
            int n = (int) in.nval;
            in.nextToken();
            int m = (int) in.nval;
            ArrayList<ArrayList<Integer>> edges = new ArrayList<ArrayList<Integer>>();
            for (int i = 0; i <= n; i++) {
                edges.add(new ArrayList<Integer>());
            }
            for (int i = 0; i < m; i++) {
                in.nextToken();
                int from = (int) in.nval;
                in.nextToken();
                int to = (int) in.nval;
                edges.get(from).add(to);
            }
            StronglyConnectedComponents connectedComponents = new StronglyConnectedComponents(edges);
            int sccn = connectedComponents.getSccn();
            int ans = 0;
            if (sccn == 1) {
                ans = n;
            } else {
                ArrayList<ArrayList<Integer>> dag = connectedComponents.getDirectedAcyclicReducedPointGraph();
                int zeroOut = 0;
                int outScc = 0;
                for (int i = 1; i <= sccn; i++) {
                    if (dag.get(i).size() == 0) {
                        zeroOut++;
                        outScc = i;
                    }
                }
                if (zeroOut > 1) {
                    ans = 0;
                } else {
                    int[] scc = connectedComponents.getScc();
                    for (int i = 1; i <= n; i++) {
                        if (scc[i] == outScc) {
                            ans++;
                        }
                    }
                }
            }
            out.println(ans);
            out.flush();
        }
    }

    private static class StronglyConnectedComponents {

        private final ArrayList<ArrayList<Integer>> nextMap;
        private int n;
        private final int[] stack;
        private int stackSize;
        private int cnt;
        private final int[] dfn;
        private final int[] low;
        private final int[] scc;
        private int sccn;

        public StronglyConnectedComponents(ArrayList<ArrayList<Integer>> nextMap) {
            this.nextMap = nextMap;
            n = nextMap.size();
            stack = new int[n];
            stackSize = 0;
            dfn = new int[n];
            low = new int[n];
            cnt = 0;
            scc = new int[n];
            sccn = 0;
            n--;
            createScc();
        }

        private void createScc() {
            for (int i = 1; i <= n; i++) {
                if (dfn[i] == 0) {
                    tarjan(i);
                }
            }
        }

        private void tarjan(int cur) {
            low[cur] = dfn[cur] = ++cnt;
            stack[stackSize++] = cur;
            for (int next : nextMap.get(cur)) {
                if (dfn[next] == 0) {
                    tarjan(next);
                }
                if (scc[next] == 0) {
                    low[cur] = Math.min(low[cur], low[next]);
                }
            }
            if (low[cur] == dfn[cur]) {
                sccn++;
                int findCur = 0;
                do {
                    findCur = stack[--stackSize];
                    scc[findCur] = sccn;
                } while (findCur != cur);
            }
        }

        public int[] getScc() {
            return scc;
        }

        public int getSccn() {
            return sccn;
        }

        public ArrayList<ArrayList<Integer>> getDirectedAcyclicReducedPointGraph() {
            ArrayList<ArrayList<Integer>> dag = new ArrayList<ArrayList<Integer>>();
            for (int i = 0; i <= sccn; i++) {
                dag.add(new ArrayList<Integer>());
            }
            for (int cur = 1; cur <= n; cur++) {
                HashSet<Integer> isVisited = new HashSet<Integer>();
                for (int next : nextMap.get(cur)) {
                    if (scc[cur] != scc[next] && !isVisited.contains(scc[next])) {
                        dag.get(scc[cur]).add(scc[next]);
                        isVisited.add(scc[next]);
                    }
                }
            }
            return dag;
        }

    }

}
```

> - **缩点后的DAG中讨论出度入度的题型**

```java
// For Most Online Judge systems

import java.io.*;
import java.util.*;

public class Main {

    public static int MAXN = 10001;
    public static int MAXM = 50001;
    public static int n, m;
    public static int[] a = new int[MAXM];
    public static int[] b = new int[MAXM];

    public static int[] head = new int[MAXN];
    public static int[] nxt = new int[MAXM];
    public static int[] to = new int[MAXM];
    public static int cntg;

    public static int[] dfn = new int[MAXN];
    public static int[] low = new int[MAXN];
    public static int cntd;

    public static int[] sta = new int[MAXN];
    public static int top;

    public static int[] belong = new int[MAXN];
    public static int[] sccSiz = new int[MAXN];
    public static int sccCnt;

    public static int[] outdegree = new int[MAXN];

    public static void addEdge(int u, int v) {
        nxt[++cntg] = head[u];
        to[cntg] = v;
        head[u] = cntg;
    }

    public static void tarjan(int u) {
        dfn[u] = low[u] = ++cntd;
        sta[++top] = u;
        for (int e = head[u]; e > 0; e = nxt[e]) {
            int v = to[e];
            if (dfn[v] == 0) {
                tarjan(v);
                low[u] = Math.min(low[u], low[v]);
            } else {
                if (belong[v] == 0) {
                    low[u] = Math.min(low[u], dfn[v]);
                }
            }
        }
        if (dfn[u] == low[u]) {
            sccCnt++;
            int pop;
            do {
                pop = sta[top--];
                belong[pop] = sccCnt;
                sccSiz[sccCnt]++;
            } while (pop != u);
        }
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        n = in.nextInt();
        m = in.nextInt();
        for (int i = 1; i <= m; i++) {
            a[i] = in.nextInt();
            b[i] = in.nextInt();
            addEdge(a[i], b[i]);
        }
        for (int i = 1; i <= n; i++) {
            if (dfn[i] == 0) {
                tarjan(i);
            }
        }
        for (int i = 1; i <= m; i++) {
            int scc1 = belong[a[i]];
            int scc2 = belong[b[i]];
            if (scc1 != scc2) {
                outdegree[scc1]++;
            }
        }
        int num = 0, siz = 0;
        for (int i = 1; i <= sccCnt; i++) {
            if (outdegree[i] == 0) {
                num++;
                siz = sccSiz[i];
            }
            if (num > 1) {
                siz = 0;
                break;
            }
        }
        out.println(siz);
        out.flush();
        out.close();
    }

    // 读写工具类
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}
```
