# [USACO5.3]校园网Network of Schools

## [[USACO5.3]校园网Network of Schools](<https://www.luogu.com.cn/problem/P2746>)

> - **Question 1**
>   - 一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 `B` 在 `A` 学校的分发列表中， `A` 也不一定在 `B` 学校的列表中。
>   - 你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 `A` ）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 `B` ）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。
>   - 题目翻译来自 `NOCOW` 。题目来自 `USACO Training Section 5.3` 。
>   - **输入描述**
>     - 输入文件的第一行包括一个正整数 `N` ，表示网络中的学校数目。学校用前 `N` 个正整数标识。
>     - 接下来 `N` 行中每行都表示一个接收学校列表（分发列表），第 `i + 1` 行包括学校 `i` 的接收学校的标识符。每个列表用 `0` 结束，空列表只用一个 `0` 表示。
>   - **输出描述**
>     - 你的程序应该在输出文件中输出两行。
>     - 第一行应该包括一个正整数，表示子任务 `A` 的解。
>     - 第二行应该包括一个非负整数，表示子任务 `B` 的解。
>   - **Tips**
>     - `2 <= N <= 100`

## [1192. 查找集群内的关键连接](https://leetcode.cn/problems/critical-connections-in-a-network/)

> - **Question 2**
>   - 力扣数据中心有 `n` 台服务器，分别按从 `0` 到 `n - 1` 的方式进行了编号。它们之间以服务器到服务器的形式相互连接组成了一个内部集群，连接是无向的。用 `connections` 表示集群网络， `connections[i] = [a, b]` 表示服务器 `a` 和 `b` 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。
>   - 关键连接是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。
>   - 请你以任意顺序返回该集群内的所有关键连接。
>   - **Tips**
>     - `2 <= n <= 10^5`
>     - `n - 1 <= connections.length <= 10^5`
>     - `0 <= ai, bi <= n - 1`
>     - `ai != bi`
>     - 不存在重复的连接

## [P2812 校园网络【[USACO]Network of Schools加强版】](https://www.luogu.com.cn/problem/P2812)

> - **Question 3**
>   - 一共有 `n` 个节点， `m` 条有向边，消息只能顺着有向边传递，
打印至少需要在几个节点投放消息，才能让所有节点，都能收到消息。
打印至少需要添加几条边，才能让任意两个节点之间，都能传递消息。
>   - **Tips**
>     - `1 <= n <= 10^4`
>     - `1 <= m <= 5 * 10^4`

## Java

> - **Question 1: Tarjan缩点**
>   - 所有学校建立图，让 `tarjan` 生成缩点图，然后统计缩点图中入度为 `0` 和出度为 `0` 的超级节点（强连通分量）个数。缩点图中入度为 `0` 的点的个数就是子任务 `A` 的解，而入度为 `0` 和出度为 `0` 的节点数中的最大值即为子任务 `B` 的解。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.ArrayList;
import java.util.HashSet;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while (in.nextToken() != StreamTokenizer.TT_EOF) {
            int n = (int) in.nval;
            ArrayList<ArrayList<Integer>> edges = new ArrayList<ArrayList<Integer>>();
            for (int i = 0; i <= n; i++) {
                edges.add(new ArrayList<Integer>());
            }
            for (int from = 1; from <= n; from++) {
                do {
                    in.nextToken();
                    int to = (int) in.nval;
                    if (to == 0) {
                        break;
                    } else {
                        edges.get(from).add(to);
                    }
                } while (true);
            }
            StronglyConnectedComponents scc = new StronglyConnectedComponents(edges);
            int sccn = scc.getSccn();
            int[] inDegrees = new int[sccn + 1];
            int[] outDegrees = new int[sccn + 1];
            ArrayList<ArrayList<Integer>> dag = scc.getDirectedAcyclicReducedPointGraph();
            for (int i = 1; i <= sccn; i++) {
                for (int j : dag.get(i)) {
                    outDegrees[i]++;
                    inDegrees[j]++;
                }
            }
            int zeroIn = 0;
            int zeroOut = 0;
            for (int i = 1; i <= sccn; i++) {
                if (inDegrees[i] == 0) {
                    zeroIn++;
                }
                if (outDegrees[i] == 0) {
                    zeroOut++;
                }
            }
            out.println(zeroIn);
            out.println(sccn == 1 ? 0 : Math.max(zeroIn, zeroOut));
            out.flush();
        }
    }

    private static class StronglyConnectedComponents {

        private final ArrayList<ArrayList<Integer>> nextMap;
        private int n;
        private final int[] stack;
        private int stackSize;
        private int cnt;
        private final int[] dfn;
        private final int[] low;
        private final int[] scc;
        private int sccn;

        public StronglyConnectedComponents(ArrayList<ArrayList<Integer>> nextMap) {
            this.nextMap = nextMap;
            n = nextMap.size();
            stack = new int[n];
            stackSize = 0;
            dfn = new int[n];
            low = new int[n];
            cnt = 0;
            scc = new int[n];
            sccn = 0;
            n--;
            createScc();
        }

        private void createScc() {
            for (int i = 1; i <= n; i++) {
                if (dfn[i] == 0) {
                    tarjan(i);
                }
            }
        }

        private void tarjan(int cur) {
            low[cur] = dfn[cur] = ++cnt;
            stack[stackSize++] = cur;
            for (int next : nextMap.get(cur)) {
                if (dfn[next] == 0) {
                    tarjan(next);
                }
                if (scc[next] == 0) {
                    low[cur] = Math.min(low[cur], low[next]);
                }
            }
            if (low[cur] == dfn[cur]) {
                sccn++;
                int findCur = 0;
                do {
                    findCur = stack[--stackSize];
                    scc[findCur] = sccn;
                } while (findCur != cur);
            }
        }

        public int[] getScc() {
            return scc;
        }

        public int getSccn() {
            return sccn;
        }

        public ArrayList<ArrayList<Integer>> getDirectedAcyclicReducedPointGraph() {
            ArrayList<ArrayList<Integer>> dag = new ArrayList<ArrayList<Integer>>();
            for (int i = 0; i <= sccn; i++) {
                dag.add(new ArrayList<Integer>());
            }
            for (int cur = 1; cur <= n; cur++) {
                HashSet<Integer> isVisited = new HashSet<Integer>();
                for (int next : nextMap.get(cur)) {
                    if (scc[cur] != scc[next] && !isVisited.contains(scc[next])) {
                        dag.get(scc[cur]).add(scc[next]);
                        isVisited.add(scc[next]);
                    }
                }
            }
            return dag;
        }

    }

}
```

> - **Question 2: Tarjan**

```java
import java.util.*;

class Solution {

    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        // 常规生成邻接表
        List<Integer>[] adt = new List[n];
        for (int i = 0; i < n; i++) adt[i] = new ArrayList<>();
        for (List<Integer> e : connections) {
            int u = e.get(0), v = e.get(1);
            adt[u].add(v);
            adt[v].add(u);
        }

        List<List<Integer>> ret = new ArrayList<>();
        // dfs过程中，初次访问某个节点时的时间戳
        int[] time = new int[n];
        // 每个节点的最小追溯值
        int[] low = new int[n];
        // 自增数字，用来赋值给节点的时间戳
        int[] num = {0};
        // 从顶点 0 开始dfs，并认为其 前驱节点为 0
        dfs(0, 0, adt, time, low, ret, num);
        return ret;
    }

    private void dfs(int u, int pa, List<Integer>[] adt, int[] time, int[] low, List<List<Integer>> ret, int[] num) {
        low[u] = time[u] = ++num[0];
        for (int v : adt[u]) {
            if (time[v] == 0) {
                // 代表dfs发现新节点 v
                dfs(v, u, adt, time, low, ret, num);
                low[u] = Math.min(low[u], low[v]);
                if (low[v] > time[u]) {
                    //发现桥边，添加到结果集
                    ret.add(Arrays.asList(u, v));
                }
            } else if (time[v] < time[u] && v != pa) {
                // v 已经在 u 之前被访问过了。因为是无向图，u 可以反向访问到其 【dfs搜索树】上的父节点，此时需要跳过。
                low[u] = Math.min(low[u], time[v]);
                // 这里为什么用 time[v]而不用 low[v]，我一开始真的很困惑。
                // 在这道题的场景下，二者其实都可以。
                // low[u] = Math.min(low[u], low[v]);
            }
            // 无需被处理
            // else if(time[v] > time[u]){}
        }
    }

}
```

> - **Question 3: 缩点后的DAG中讨论出度入度的题型**

```java
// 需要最少边数的证明和构造

// For Most Online Judge systems

import java.io.*;
import java.util.*;

public class Main {

    public static int MAXN = 100001;
    public static int MAXM = 500001;
    public static int n, m;
    public static int[] a = new int[MAXM];
    public static int[] b = new int[MAXM];

    public static int[] head = new int[MAXN];
    public static int[] nxt = new int[MAXM];
    public static int[] to = new int[MAXM];
    public static int cntg;

    public static int[] dfn = new int[MAXN];
    public static int[] low = new int[MAXN];
    public static int cntd;

    public static int[] sta = new int[MAXN];
    public static int top;

    public static int[] belong = new int[MAXN];
    public static int sccCnt;

    public static int[] outdegree = new int[MAXN];
    public static int[] indegree = new int[MAXN];

    public static void addEdge(int u, int v) {
        nxt[++cntg] = head[u];
        to[cntg] = v;
        head[u] = cntg;
    }

    public static void tarjan(int u) {
        dfn[u] = low[u] = ++cntd;
        sta[++top] = u;
        for (int e = head[u]; e > 0; e = nxt[e]) {
            int v = to[e];
            if (dfn[v] == 0) {
                tarjan(v);
                low[u] = Math.min(low[u], low[v]);
            } else {
                if (belong[v] == 0) {
                    low[u] = Math.min(low[u], dfn[v]);
                }
            }
        }
        if (dfn[u] == low[u]) {
            sccCnt++;
            int pop;
            do {
                pop = sta[top--];
                belong[pop] = sccCnt;
            } while (pop != u);
        }
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        n = in.nextInt();
        m = 0;
        for (int i = 1, x; i <= n; i++) {
            x = in.nextInt();
            while (x != 0) {
                m++;
                a[m] = i;
                b[m] = x;
                addEdge(a[m], b[m]);
                x = in.nextInt();
            }
        }
        for (int i = 1; i <= n; i++) {
            if (dfn[i] == 0) {
                tarjan(i);
            }
        }
        if (sccCnt == 1) {
            out.println("1");
            out.println("0");
        } else {
            for (int i = 1; i <= m; i++) {
                int scc1 = belong[a[i]];
                int scc2 = belong[b[i]];
                if (scc1 != scc2) {
                    outdegree[scc1]++;
                    indegree[scc2]++;
                }
            }
            int outZero = 0;
            int inZero = 0;
            for (int i = 1; i <= sccCnt; i++) {
                if (outdegree[i] == 0) {
                    outZero++;
                }
                if (indegree[i] == 0) {
                    inZero++;
                }
            }
            out.println(inZero);
            out.println(Math.max(outZero, inZero));
        }
        out.flush();
        out.close();
    }

    // 读写工具类
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}
```
