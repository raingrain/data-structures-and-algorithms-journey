# 破解保险箱

## [753. 破解保险箱](https://leetcode.cn/problems/cracking-the-safe/)

> - **Question**
>   - 给定正数 `n` ，表示密码有 `n` 位，给定正数 `k` ，表示每一位可能的数字是 `[0 ~ k - 1]` 。
>   - 密码有 `k^n` 个可能性，构造一个字符串，其中的连续子串包含所有可能的密码。
>   - 先保证字符串的长度最短，作为加强要求，保证字典序尽量的小，返回字符串。
>   - **Tips**
>     - `1 <= n <= 4`
>     - `1 <= k <= 10`

## Java

> - **Question**

```java
// 构造序列题型
// de Bruijn序列，其实就是生成欧拉回路
// 总长度为  k的n次方 + n - 1

class Solution {

    public int MAXN = 5001;
    public int n, k, m;
    public int[] cur = new int[MAXN];
    public int[] path = new int[MAXN];
    public int cntp;

    public int[][] sta = new int[MAXN][2];
    public int u, e;
    public int stacksize;

    public void push(int u, int e) {
        sta[stacksize][0] = u;
        sta[stacksize][1] = e;
        stacksize++;
    }

    public void pop() {
        stacksize--;
        u = sta[stacksize][0];
        e = sta[stacksize][1];
    }

    public void prepare(int len, int num) {
        n = len;
        k = num;
        m = 1;
        for (int i = 1; i <= n - 1; i++) {
            m *= k;
        }
        for (int i = 0; i < m; i++) {
            cur[i] = 0;
        }
        cntp = 0;
    }

    // 递归版
    public void euler1(int u, int e) {
        while (cur[u] < k) {
            int ne = cur[u]++;
            euler1((u * k + ne) % m, ne);
        }
        path[++cntp] = e;
    }

    // 迭代版
    public void euler2(int node, int edge) {
        stacksize = 0;
        push(node, edge);
        while (stacksize > 0) {
            pop();
            if (cur[u] < k) {
                int ne = cur[u]++;
                push(u, e);
                push((u * k + ne) % m, ne);
            } else {
                path[++cntp] = e;
            }
        }
    }

    public String crackSafe(int len, int num) {
        prepare(len, num);
        euler1(0, -1);
        // euler2(0, -1);
        StringBuilder str = new StringBuilder();
        for (int i = 1; i <= n - 1; i++) {
            str.append("0");
        }
        for (int i = cntp - 1; i >= 1; i--) {
            str.append(path[i]);
        }
        return str.toString();
    }

}
```
