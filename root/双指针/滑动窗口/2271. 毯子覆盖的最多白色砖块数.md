# [2271. æ¯¯å­è¦†ç›–çš„æœ€å¤šç™½è‰²ç –å—æ•°](https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/)

> - ***Question 1***
>   - ç»™ä½ ä¸€ä¸ªæœ‰åºä¸€ç»´æ•´æ•°æ•°ç»„ `tiles` ï¼Œå…¶ä¸­ `tiles[i]` è¡¨ç¤ºå½“å‰ä½ç½®ä¸Šæœ‰ç“·ç –ï¼›
>   - åŒæ—¶ç»™ä½ ä¸€ä¸ªæ•´æ•° `carpetLen` ï¼Œè¡¨ç¤ºå¯ä»¥æ”¾åœ¨ä»»ä½•ä½ç½®çš„ä¸€å—æ¯¯å­çš„é•¿åº¦ï¼›
>   - è¯·ä½ è¿”å›ä½¿ç”¨è¿™å—æ¯¯å­æœ€å¤šå¯ä»¥ç›–ä½çš„ç“·ç –æ•°ã€‚
> - ***Question 2***
>   - å¦‚æœä¸Šé¢˜ä¸­ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ `tiles` ï¼Œå…¶ä¸­ `tiles[i] = [li, ri]` ï¼Œè¡¨ç¤ºæ‰€æœ‰åœ¨ `li <= j <= ri` ä¹‹é—´çš„æ¯ä¸ªä½ç½® `j` éƒ½ä¸Šéƒ½æœ‰ç“·ç –ï¼Œè¯·ä½ è¿”å›ä½¿ç”¨è¿™å—æ¯¯å­æœ€å¤šå¯ä»¥ç›–ä½çš„ç“·ç –æ•°ï¼›

---

## *Java*

> - ***è´ªå¿ƒ + æ»‘åŠ¨çª—å£***
>   - äºŒç»´å…¥å‚çš„è´ªå¿ƒç­–ç•¥æŒ‡ä¸€å®šå­˜åœ¨è‡³å°‘ä¸€ç§è¦†ç›–ç –å—æœ€å¤šçš„æ–¹æ¡ˆï¼Œå®ƒçš„èµ·å§‹ä½ç½®æ˜¯åœ¨æŸä¸€æ®µè¿ç»­ç“·ç –çš„ç¬¬ä¸€ä¸ªï¼Œè¯æ˜å¦‚ä¸‹ï¼š
>     - å‡è®¾æŸä¸€ç§èµ·å§‹ä½ç½®ä¸åœ¨æŸä¸€æ®µè¿ç»­ç“·ç –ç¬¬ä¸€ä¸ªçš„è¦†ç›–æ–¹æ¡ˆè¦†ç›–çš„æ•°é‡é«˜äºä»»ä½•èµ·å§‹ä½ç½®åœ¨è¿ç»­ç“·ç –ç¬¬ä¸€ä¸ªçš„æ–¹æ¡ˆï¼Œåˆ™ä¼šæœ‰ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š
>       - èµ·å§‹ä½ç½®æ²¡æœ‰ç“·ç –ï¼Œæ­¤æ—¶å‡è®¾èµ·å§‹ä½ç½®è·ç¦»ä¸‹ä¸€ä¸ªç“·ç –ä¸º `m` ï¼ˆå¦‚æœä¸å­˜åœ¨ä¸‹ä¸€æ®µç“·ç –ï¼Œåˆ™è¦†ç›–æ•°é‡ä¸€å®šä¸º0ï¼Œä¸ç¬¦åˆè¦æ±‚ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†èµ·å§‹ä½ç½®å³ç§» `m` æ ¼ï¼Œç”±äºç§»å¼€çš„è¿™ `m` æ ¼æ²¡æœ‰ç“·ç –ï¼Œå› æ­¤æ•°é‡ä¸€å®šä¸ä¼šå‡å°‘ï¼Œè¿™å°±äº§ç”Ÿäº†çŸ›ç›¾ï¼›
>       - èµ·å§‹ä½ç½®åœ¨æŸæ®µè¿ç»­ç“·ç –çš„ä¸­é—´ä½ç½®ï¼Œæ­¤æ—¶å‡è®¾èµ·å§‹ä½ç½®è·ç¦»è¯¥æ®µç“·ç –èµ·å§‹ä½ç½®è·ç¦»ä¸º `m` ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†èµ·å§‹ä½ç½®å·¦ç§» `m` æ ¼ï¼Œç”±äºåŠ å…¥çš„è¿™ `m` æ ¼ä¸€å®šéƒ½æœ‰ç“·ç –ï¼Œå› æ­¤æ•°é‡ä¸€å®šä¸ä¼šå‡å°‘ï¼Œè¿™ä¹Ÿäº§ç”Ÿäº†çŸ›ç›¾ã€‚
>   - å¯¹äºäºŒç»´æ•°ç»„çš„å…¥å‚ï¼Œå…ˆå°†ç“·ç –åŒºé—´æ’å¥½åºï¼Œå¯¹äºè´ªå¿ƒç­–ç•¥ç›´æ¥è®¾ç½®ä¸€ä¸ªå®šé•¿çš„æ¯›æ¯¯åŒºé—´ï¼Œå†è®¾ç½®ä¸€ä¸ªå½“å‰æ¯›æ¯¯è¦†ç›–çš„ç“·ç –æ•° `tileCoverByCarpet` ï¼Œç”¨ä¸€ä¸ªæŒ‡é’ˆ `p` æ¥éå†ç“·ç –åŒºé—´ï¼š
>     - å½“å‰ç“·ç –åŒºé—´çš„é•¿åº¦å¦‚æœå¤§äºç­‰äºæ¯›æ¯¯é•¿åº¦åˆ™ç›´æ¥è¿”å›æ¯›æ¯¯é•¿åº¦ï¼›
>     - å½“å‰ç“·ç –åŒºé—´åœ¨æ¯›æ¯¯å†…éƒ¨ï¼Œ`tileCoverByCarpet` åŠ ä¸Šè¿™æ®µåŒºé—´é•¿åº¦ï¼Œ`p` å³ç§»ï¼›
>     - å½“å‰ç“·ç –æœ‰ä¸€éƒ¨åˆ†åœ¨æ¯›æ¯¯å†…ï¼ˆæ¯›æ¯¯å³è¾¹ç•Œåœ¨ç“·ç –åŒºé—´å†…ï¼‰ï¼Œ`tileCoverByCarpet` åŠ ä¸Šè¿™ä¸€éƒ¨åˆ†ï¼›å½“å‰ç“·ç –å®Œå…¨ä¸åœ¨æ¯›æ¯¯å†…ï¼ˆç“·ç –å·¦è¾¹ç•Œå¤§äºæ¯›æ¯¯å³è¾¹ç•Œï¼‰ã€‚è¿™ä¸¤éƒ¨åˆ†ç›´æ¥å¼•èµ·æ–°ç­”æ¡ˆç”Ÿæˆï¼Œç„¶å `tileCoverByCarpet` å‡å»å½“å‰æ¯›æ¯¯è¦†ç›–çš„ç¬¬ä¸€ä¸ªç“·ç –åŒºé—´çš„é•¿åº¦ï¼Œæ¯›æ¯¯åŒºé—´è·³åˆ°ä¸‹ä¸€ä¸ªç“·ç –åŒºé—´å¹¶ä»å…¶å·¦è¾¹ç•Œå¼€å§‹ã€‚
>   - å¯¹äºä¸€ç»´æ•°ç»„çš„å…¥å‚ï¼Œç›´æ¥å‡†å¤‡åŒæŒ‡é’ˆï¼Œå³è¾¹å…ˆè¿›åŠ¨ç›´è‡³å½“å·¦å³æŒ‡é’ˆä¹‹é—´å¯¹åº”çš„å®é™…é•¿åº¦ç­‰äºæ¯¯å­é•¿åº¦æ—¶ï¼Œè®°å½•å½“å‰çš„ `right - left` ä½œä¸ºä¸€ä¸ªç­”æ¡ˆä¸ä¹‹å‰çš„æ¯”è¾ƒï¼Œç„¶åè®©å·¦è¾¹å³ç§»ä¸€æ­¥ï¼Œå³è¾¹ç»§ç»­è¿›åŠ¨è‡³é‡åˆ°æœ€å³è¾¹ç•Œï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(N)` ã€‚
> - ***è´ªå¿ƒ + äºŒåˆ†æŸ¥æ‰¾***
>   - å¯¹äºä¸€ç»´æ•°ç»„çš„å…¥å‚ï¼Œæˆ‘ä»¬ä»¥éå†æ¯ä¸ªç“·ç –å¹¶æŠŠå…¶ä½œä¸ºæ¯›æ¯¯è¦†ç›–çš„æœ€åä¸€ä¸ªç“·ç –ï¼Œç„¶åè®¡ç®—ç†è®ºä¸­æ¯›æ¯¯å·¦è¾¹è¦†ç›–çš„ä½ç½®ï¼Œåˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾åœ¨è¯¥ç†è®ºå€¼ä½ç½®å³è¾¹è·ç¦»å…¶æœ€è¿‘çš„ç“·ç –çš„ä½ç½®ï¼Œç„¶ååˆ©ç”¨ä½ç½®ç›¸å‡å¾—åˆ°è¦†ç›–ç“·ç –æ•°è¿›è¡Œæ¯”è¾ƒï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(N * logN)` .

```java
class Solution {
    
    // ä¼ é€’äºŒç»´æ•°ç»„
    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {
        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);
        // æ¯›æ¯¯å·¦å³æŒ‡é’ˆ
        int carpetLeft = 0;
        int carpetRight = tiles[carpetLeft][0] + carpetLen - 1;
        // å½“å‰è¢«æ¯›æ¯¯è¦†ç›–çš„ç“·ç –æ•°
        int tileCoverByCarpet = 0;
        // ç“·ç –åŒºé—´éå†æŒ‡é’ˆ
        int p = 0;
        // ç»“æœ
        int ans = 0;
        while (p < tiles.length) {
            int curTileLen = tiles[p][1] - tiles[p][0] + 1;
            // ç“·ç –åŒºé—´é•¿è¿‡æ¯›æ¯¯
            if (curTileLen >= carpetLen) {
                return carpetLen;
            } else {
                if (tiles[p][1] <= carpetRight) {
                    // ç“·ç –åŒºé—´åœ¨æ¯›æ¯¯å†…
                    tileCoverByCarpet += curTileLen;
                    p++;
                } else {
                    // ç“·ç –åŒºé—´ï¼ˆä¸€éƒ¨åˆ†æˆ–è€…å…¨éƒ¨ï¼‰åœ¨æ¯›æ¯¯å¤–
                    ans = tiles[p][0] > carpetRight ? Math.max(ans, tileCoverByCarpet) : Math.max(ans, tileCoverByCarpet + carpetRight - tiles[p][0] + 1);
                    // æ¯›æ¯¯åŒºé—´åç§»å¹¶å‡å»ä¹‹å‰çš„
                    tileCoverByCarpet -= tiles[carpetLeft][1] - tiles[carpetLeft][0] + 1;
                    carpetRight = tiles[++carpetLeft][0] + carpetLen - 1;
                }
            }
        }
        return Math.max(ans, tileCoverByCarpet);
    }
    
    // ä¼ é€’ä¸€ç»´æ•°ç»„
    public int maximumWhiteTiles(int[] tiles, int carpetLen) {
        int left = 0;
        int right = 0;
        int ans = 0;
        while (left < tiles.length) {
            // å½“é‡åˆ°åœ¨åœ°æ¯¯å³è¾¹çš„ç“·ç –æ—¶åœæ­¢
            while (right < tiles.length && tiles[right] - tiles[left] <= carpetLen) {
                right++;
            }
            ans = Math.max(ans, right - (left++));
        }
        return ans;
    }
    
    // è´ªå¿ƒåŠ äºŒåˆ†
    public int maximumWhiteTilesByBinarySearch(int[] tiles, int carpetLen) {
        int res = 1;
        for (int i = 0; i < tiles.length; i++) {
            int nearest = nearestIndex(tiles, i, tiles[i] - carpetLen);
            res = Math.max(res, i - nearest + 1);
        }
        return res;
    }
    
    // åœ¨ä¸€ä¸ªæœ‰åºæ•°ç»„arrä¸­æ‰¾åˆ°å¤§äºç­‰äºvalueä¸”æœ€æ¥è¿‘valueçš„å€¼çš„ä½ç½®
    public int nearestIndex(int[] arr, int R, int value) {
        int L = 0;
        // æœ€å¼€å§‹ä¸€å®šæœ€å¤§ï¼Œå› ä¸ºvalue<arr[R]
        int index = R;
        while (L <= R) {
            int mid = L + (R - L) >> 1;
            // æˆ‘è¿˜æ¯”ä½ å¤§æˆ‘å¾€å·¦ç§»
            if (arr[mid] >= value) {
                index = mid;
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        return index;
    }
    
}
```

---

### *TypeScript*

> - ***è´ªå¿ƒ + æ»‘åŠ¨çª—å£***
>   - å‚è€ƒjavaä¸­å…¥å‚ä¸ºäºŒç»´æ•°ç»„çš„éƒ¨åˆ†

```typescript
function maximumWhiteTiles(tiles: number[][], carpetLen: number): number {
    tiles.sort((a, b) => a[0] - b[0]);
    let carpetLeft = 0;
    let carpetRight = tiles[carpetLeft][0] + carpetLen - 1;
    let tileCoverByCarpet = 0;
    let p = 0;
    let ans = 0;
    while (p < tiles.length) {
        const curTileLen = tiles[p][1] - tiles[p][0] + 1;
        if (curTileLen >= carpetLen) {
            return carpetLen;
        } else {
            if (tiles[p][1] <= carpetRight) {
                tileCoverByCarpet += curTileLen;
                p++;
            } else {
                ans = tiles[p][0] > carpetRight ? Math.max(ans, tileCoverByCarpet) : Math.max(ans, tileCoverByCarpet + carpetRight - tiles[p][0] + 1);
                tileCoverByCarpet -= tiles[carpetLeft][1] - tiles[carpetLeft][0] + 1;
                carpetRight = tiles[++carpetLeft][0] + carpetLen - 1;
            }
        }
    }
    return Math.max(ans, tileCoverByCarpet);
};
```

---

> ğŸš©***last change: 2022/9/25***

---
